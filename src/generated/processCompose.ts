/**
 * Generated by orval v8.4.0 ðŸº
 * Do not edit manually.
 * Process Compose API
 * This is a sample Process Compose server.
 * OpenAPI spec version: 1.0
 */
import { pcFetch } from '../orval/pcMutator.js';
export interface ApiErrorResponse {
  error?: string;
}

export interface ApiLogsResponse {
  logs?: string[];
}

export interface ApiNameResponse {
  name?: string;
}

export interface ApiProjectNameResponse {
  projectName?: string;
}

export interface ApiStatusResponse {
  status?: string;
}

export interface HealthExecProbe {
  command?: string;
  workingDir?: string;
}

export type HealthHttpProbeHeaders = {[key: string]: string};

export interface HealthHttpProbe {
  headers?: HealthHttpProbeHeaders;
  host?: string;
  numPort?: number;
  path?: string;
  port?: string;
  scheme?: string;
  statusCode?: number;
}

export interface HealthProbe {
  exec?: HealthExecProbe;
  failureThreshold?: number;
  httpGet?: HealthHttpProbe;
  initialDelay?: number;
  periodSeconds?: number;
  successThreshold?: number;
  timeoutSeconds?: number;
}

export type TypesDependencyNodeDependsOn = { [key: string]: unknown };

export interface TypesDependencyNode {
  depends_on?: TypesDependencyNodeDependsOn;
  is_ready?: string;
  name?: string;
  process_status?: string;
}

export type TypesDependencyGraphNodes = {[key: string]: TypesDependencyNode};

export interface TypesDependencyGraph {
  nodes?: TypesDependencyGraphNodes;
}

export type TypesProcessCondition = typeof TypesProcessCondition[keyof typeof TypesProcessCondition];


export const TypesProcessCondition = {
  ProcessConditionCompleted: 0,
  ProcessConditionCompletedSuccessfully: 1,
  ProcessConditionHealthy: 2,
  ProcessConditionStarted: 3,
  ProcessConditionLogReady: 4,
} as const;

export type TypesProcessDependencyExtensions = { [key: string]: unknown };

export interface TypesProcessDependency {
  condition?: TypesProcessCondition;
  extensions?: TypesProcessDependencyExtensions;
}

export interface TypesDependsOnConfig {[key: string]: TypesProcessDependency}

export interface TypesLogRotationConfig {
  /** Compress determines if the rotated log files should be compressed
using gzip. The default is not to perform compression. */
  compress?: boolean;
  /** Directory to log to when filelogging is enabled */
  directory?: string;
  /** Filename is the name of the logfile which will be placed inside the directory */
  filename?: string;
  /** MaxAge the max age in days to keep a logfile */
  maxAge?: number;
  /** MaxBackups the max number of rolled files to keep */
  maxBackups?: number;
  /** MaxSize the max size in MB of the logfile before it's rolled */
  maxSize?: number;
}

export interface TypesLoggerConfig {
  /** AddTimestamp adds timestamp to log */
  addTimestamp?: boolean;
  /** DisableJSON disables log JSON formatting */
  disableJSON?: boolean;
  /** FieldsOrder is the order in which fields are logged */
  fieldsOrder?: string[];
  /** FlushEachLine flushes the logger on each line */
  flushEachLine?: boolean;
  /** NoColor disables coloring */
  noColor?: boolean;
  /** NoMetadata disables log metadata (process, replica) */
  noMetadata?: boolean;
  /** Rotation is the configuration for logging rotation */
  rotation?: TypesLogRotationConfig;
  /** TimestampFormat is the format of the timestamp */
  timestampFormat?: string;
}

export interface TypesMemoryState {
  allocated?: number;
  gcCycles?: number;
  systemMemory?: number;
  totalAllocated?: number;
}

export type TypesProcessConfigExtensions = { [key: string]: unknown };

export type TypesRestartPolicy = typeof TypesRestartPolicy[keyof typeof TypesRestartPolicy];


export const TypesRestartPolicy = {
  RestartPolicyNo: 0,
  RestartPolicyAlways: 1,
  RestartPolicyOnFailure: 2,
  RestartPolicyExitOnFailure: 3,
} as const;

export interface TypesRestartPolicyConfig {
  backoffSeconds?: number;
  exitOnEnd?: boolean;
  exitOnSkipped?: boolean;
  maxRestarts?: number;
  restart?: TypesRestartPolicy;
}

export interface TypesScheduleConfig {
  /** Cron expression for cron-based scheduling (e.g., "0 2 * * *") */
  cron?: string;
  /** Interval for interval-based scheduling (e.g., "30m", "1h", "5s") */
  interval?: string;
  /** MaxConcurrent limits concurrent executions (default: 1) */
  max_concurrent?: number;
  /** RunOnStart determines whether to run immediately when process-compose starts */
  run_on_start?: boolean;
  /** Timezone for cron expression (e.g., "UTC", "America/New_York") */
  timezone?: string;
}

export interface TypesShutDownParams {
  parentOnly?: boolean;
  shutDownCommand?: string;
  shutDownTimeout?: number;
  signal?: number;
}

export interface TypesVars {[key: string]: unknown}

export interface TypesProcessConfig {
  args?: string[];
  command?: string;
  dependsOn?: TypesDependsOnConfig;
  description?: string;
  disableAnsiColors?: boolean;
  disableDotEnv?: boolean;
  disabled?: boolean;
  entrypoint?: string[];
  environment?: string[];
  executable?: string;
  extensions?: TypesProcessConfigExtensions;
  isDaemon?: boolean;
  isDisabled?: string;
  isElevated?: boolean;
  isForeground?: boolean;
  isInteractive?: boolean;
  isTty?: boolean;
  launchTimeout?: number;
  livenessProbe?: HealthProbe;
  logLocation?: string;
  loggerConfig?: TypesLoggerConfig;
  name?: string;
  namespace?: string;
  originalConfig?: string;
  readinessProbe?: HealthProbe;
  readyLogLine?: string;
  replicaName?: string;
  replicaNum?: number;
  replicas?: number;
  restartPolicy?: TypesRestartPolicyConfig;
  schedule?: TypesScheduleConfig;
  shutDownParams?: TypesShutDownParams;
  vars?: TypesVars;
  workingDir?: string;
}

export interface TypesProcessPorts {
  name?: string;
  tcp_ports?: number[];
  udp_ports?: number[];
}

export interface TypesProcessState {
  age?: number;
  cpu?: number;
  exit_code?: number;
  has_ready_probe?: boolean;
  is_elevated?: boolean;
  is_ready?: string;
  is_running?: boolean;
  mem?: number;
  name?: string;
  namespace?: string;
  next_run_time?: string;
  password_provided?: boolean;
  pid?: number;
  restarts?: number;
  status?: string;
  system_time?: string;
}

export interface TypesProcessesState {
  data?: TypesProcessState[];
}

export interface TypesProjectState {
  fileNames?: string[];
  memoryState?: TypesMemoryState;
  processNum?: number;
  projectName?: string;
  runningProcessNum?: number;
  startTime?: string;
  upTime?: number;
  userName?: string;
  version?: string;
}

export type GetDependencyGraph400 = {[key: string]: string};

export type UpdateProcess400 = {[key: string]: string};

export type GetProcessInfo400 = {[key: string]: string};

export type LogsStreamParams = {
/**
 * Comma-separated process names to stream
 */
name: string;
/**
 * Offset from the end of the log
 */
offset: number;
/**
 * If true, continue streaming new lines
 */
follow?: boolean;
};

export type TruncateProcessLogs400 = {[key: string]: string};

export type GetProcessLogs400 = {[key: string]: string};

export type GetProcessPorts400 = {[key: string]: string};

export type RestartProcess400 = {[key: string]: string};

export type ScaleProcess400 = {[key: string]: string};

export type StartProcess400 = {[key: string]: string};

export type StopProcess400 = {[key: string]: string};

export type GetProcess400 = {[key: string]: string};

export type GetProcesses400 = {[key: string]: string};

export type StopProcesses200 = {[key: string]: string};

export type StopProcesses207 = {[key: string]: string};

export type StopProcesses400 = {[key: string]: string};

export type UpdateProject200 = {[key: string]: string};

export type UpdateProject207 = {[key: string]: string};

export type UpdateProject400 = {[key: string]: string};

export type ReloadProject200 = {[key: string]: string};

export type ReloadProject207 = {[key: string]: string};

export type ReloadProject400 = {[key: string]: string};

export type GetProjectName400 = {[key: string]: string};

export type GetProjectState500 = {[key: string]: string};

/**
 * Returns the process dependency graph with current status
 * @summary Get dependency graph
 */
export type getDependencyGraphResponse200 = {
  data: TypesDependencyGraph
  status: 200
}

export type getDependencyGraphResponse400 = {
  data: GetDependencyGraph400
  status: 400
}

export type getDependencyGraphResponseSuccess = (getDependencyGraphResponse200) & {
  headers: Headers;
};
export type getDependencyGraphResponseError = (getDependencyGraphResponse400) & {
  headers: Headers;
};

export type getDependencyGraphResponse = (getDependencyGraphResponseSuccess | getDependencyGraphResponseError)

export const getGetDependencyGraphUrl = () => {


  

  return `/graph`
}

export const getDependencyGraph = async ( options?: RequestInit): Promise<getDependencyGraphResponse> => {
  
  return pcFetch<getDependencyGraphResponse>(getGetDependencyGraphUrl(),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



/**
 * Check if server is responding
 * @summary Liveness Check
 */
export type isAliveResponse200 = {
  data: ApiStatusResponse
  status: 200
}

export type isAliveResponseSuccess = (isAliveResponse200) & {
  headers: Headers;
};
;

export type isAliveResponse = (isAliveResponseSuccess)

export const getIsAliveUrl = () => {


  

  return `/live`
}

export const isAlive = async ( options?: RequestInit): Promise<isAliveResponse> => {
  
  return pcFetch<isAliveResponse>(getIsAliveUrl(),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



/**
 * Update process
 * @summary Updates process configuration
 */
export type updateProcessResponse200 = {
  data: TypesProcessConfig
  status: 200
}

export type updateProcessResponse400 = {
  data: UpdateProcess400
  status: 400
}

export type updateProcessResponseSuccess = (updateProcessResponse200) & {
  headers: Headers;
};
export type updateProcessResponseError = (updateProcessResponse400) & {
  headers: Headers;
};

export type updateProcessResponse = (updateProcessResponseSuccess | updateProcessResponseError)

export const getUpdateProcessUrl = () => {


  

  return `/process`
}

export const updateProcess = async (typesProcessConfig: TypesProcessConfig, options?: RequestInit): Promise<updateProcessResponse> => {
  
  return pcFetch<updateProcessResponse>(getUpdateProcessUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      typesProcessConfig,)
  }
);}



/**
 * Retrieves the given process and its config
 * @summary Get process config
 */
export type getProcessInfoResponse200 = {
  data: TypesProcessConfig
  status: 200
}

export type getProcessInfoResponse400 = {
  data: GetProcessInfo400
  status: 400
}

export type getProcessInfoResponseSuccess = (getProcessInfoResponse200) & {
  headers: Headers;
};
export type getProcessInfoResponseError = (getProcessInfoResponse400) & {
  headers: Headers;
};

export type getProcessInfoResponse = (getProcessInfoResponseSuccess | getProcessInfoResponseError)

export const getGetProcessInfoUrl = (name: string,) => {


  

  return `/process/info/${name}`
}

export const getProcessInfo = async (name: string, options?: RequestInit): Promise<getProcessInfoResponse> => {
  
  return pcFetch<getProcessInfoResponse>(getGetProcessInfoUrl(name),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



/**
 * Upgrades HTTP to WebSocket and streams JSON log messages. Each message is api.LogMessage.
 * @summary Stream process logs over WebSocket
 */
export type logsStreamResponse101 = {
  data: void
  status: 101
}

export type logsStreamResponse400 = {
  data: ApiErrorResponse
  status: 400
}

;
export type logsStreamResponseError = (logsStreamResponse101 | logsStreamResponse400) & {
  headers: Headers;
};

export type logsStreamResponse = (logsStreamResponseError)

export const getLogsStreamUrl = (params: LogsStreamParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/process/logs/ws?${stringifiedParams}` : `/process/logs/ws`
}

export const logsStream = async (params: LogsStreamParams, options?: RequestInit): Promise<logsStreamResponse> => {
  
  return pcFetch<logsStreamResponse>(getLogsStreamUrl(params),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



/**
 * Truncates the process logs
 * @summary Truncate process logs
 */
export type truncateProcessLogsResponse200 = {
  data: ApiNameResponse
  status: 200
}

export type truncateProcessLogsResponse400 = {
  data: TruncateProcessLogs400
  status: 400
}

export type truncateProcessLogsResponseSuccess = (truncateProcessLogsResponse200) & {
  headers: Headers;
};
export type truncateProcessLogsResponseError = (truncateProcessLogsResponse400) & {
  headers: Headers;
};

export type truncateProcessLogsResponse = (truncateProcessLogsResponseSuccess | truncateProcessLogsResponseError)

export const getTruncateProcessLogsUrl = (name: string,) => {


  

  return `/process/logs/${name}`
}

export const truncateProcessLogs = async (name: string, options?: RequestInit): Promise<truncateProcessLogsResponse> => {
  
  return pcFetch<truncateProcessLogsResponse>(getTruncateProcessLogsUrl(name),
  {      
    ...options,
    method: 'DELETE'
    
    
  }
);}



/**
 * Retrieves the process logs
 * @summary Get process logs
 */
export type getProcessLogsResponse200 = {
  data: ApiLogsResponse
  status: 200
}

export type getProcessLogsResponse400 = {
  data: GetProcessLogs400
  status: 400
}

export type getProcessLogsResponseSuccess = (getProcessLogsResponse200) & {
  headers: Headers;
};
export type getProcessLogsResponseError = (getProcessLogsResponse400) & {
  headers: Headers;
};

export type getProcessLogsResponse = (getProcessLogsResponseSuccess | getProcessLogsResponseError)

export const getGetProcessLogsUrl = (name: string,
    endOffset: number,
    limit: number,) => {


  

  return `/process/logs/${name}/${endOffset}/${limit}`
}

export const getProcessLogs = async (name: string,
    endOffset: number,
    limit: number, options?: RequestInit): Promise<getProcessLogsResponse> => {
  
  return pcFetch<getProcessLogsResponse>(getGetProcessLogsUrl(name,endOffset,limit),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



/**
 * Retrieves process open ports
 * @summary Get process ports
 */
export type getProcessPortsResponse200 = {
  data: TypesProcessPorts
  status: 200
}

export type getProcessPortsResponse400 = {
  data: GetProcessPorts400
  status: 400
}

export type getProcessPortsResponseSuccess = (getProcessPortsResponse200) & {
  headers: Headers;
};
export type getProcessPortsResponseError = (getProcessPortsResponse400) & {
  headers: Headers;
};

export type getProcessPortsResponse = (getProcessPortsResponseSuccess | getProcessPortsResponseError)

export const getGetProcessPortsUrl = (name: string,) => {


  

  return `/process/ports/${name}`
}

export const getProcessPorts = async (name: string, options?: RequestInit): Promise<getProcessPortsResponse> => {
  
  return pcFetch<getProcessPortsResponse>(getGetProcessPortsUrl(name),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



/**
 * Restarts the process
 * @summary Restart a process
 */
export type restartProcessResponse200 = {
  data: ApiNameResponse
  status: 200
}

export type restartProcessResponse400 = {
  data: RestartProcess400
  status: 400
}

export type restartProcessResponseSuccess = (restartProcessResponse200) & {
  headers: Headers;
};
export type restartProcessResponseError = (restartProcessResponse400) & {
  headers: Headers;
};

export type restartProcessResponse = (restartProcessResponseSuccess | restartProcessResponseError)

export const getRestartProcessUrl = (name: string,) => {


  

  return `/process/restart/${name}`
}

export const restartProcess = async (name: string, options?: RequestInit): Promise<restartProcessResponse> => {
  
  return pcFetch<restartProcessResponse>(getRestartProcessUrl(name),
  {      
    ...options,
    method: 'POST'
    
    
  }
);}



/**
 * Scale a process
 * @summary Scale a process to a given replicas count
 */
export type scaleProcessResponse200 = {
  data: ApiNameResponse
  status: 200
}

export type scaleProcessResponse400 = {
  data: ScaleProcess400
  status: 400
}

export type scaleProcessResponseSuccess = (scaleProcessResponse200) & {
  headers: Headers;
};
export type scaleProcessResponseError = (scaleProcessResponse400) & {
  headers: Headers;
};

export type scaleProcessResponse = (scaleProcessResponseSuccess | scaleProcessResponseError)

export const getScaleProcessUrl = (name: string,
    scale: number,) => {


  

  return `/process/scale/${name}/${scale}`
}

export const scaleProcess = async (name: string,
    scale: number, options?: RequestInit): Promise<scaleProcessResponse> => {
  
  return pcFetch<scaleProcessResponse>(getScaleProcessUrl(name,scale),
  {      
    ...options,
    method: 'PATCH'
    
    
  }
);}



/**
 * Starts the process if the state is not 'running' or 'pending'
 * @summary Start a process
 */
export type startProcessResponse200 = {
  data: ApiNameResponse
  status: 200
}

export type startProcessResponse400 = {
  data: StartProcess400
  status: 400
}

export type startProcessResponseSuccess = (startProcessResponse200) & {
  headers: Headers;
};
export type startProcessResponseError = (startProcessResponse400) & {
  headers: Headers;
};

export type startProcessResponse = (startProcessResponseSuccess | startProcessResponseError)

export const getStartProcessUrl = (name: string,) => {


  

  return `/process/start/${name}`
}

export const startProcess = async (name: string, options?: RequestInit): Promise<startProcessResponse> => {
  
  return pcFetch<startProcessResponse>(getStartProcessUrl(name),
  {      
    ...options,
    method: 'POST'
    
    
  }
);}



/**
 * Sends kill signal to the process
 * @summary Stop a process
 */
export type stopProcessResponse200 = {
  data: ApiNameResponse
  status: 200
}

export type stopProcessResponse400 = {
  data: StopProcess400
  status: 400
}

export type stopProcessResponseSuccess = (stopProcessResponse200) & {
  headers: Headers;
};
export type stopProcessResponseError = (stopProcessResponse400) & {
  headers: Headers;
};

export type stopProcessResponse = (stopProcessResponseSuccess | stopProcessResponseError)

export const getStopProcessUrl = (name: string,) => {


  

  return `/process/stop/${name}`
}

export const stopProcess = async (name: string, options?: RequestInit): Promise<stopProcessResponse> => {
  
  return pcFetch<stopProcessResponse>(getStopProcessUrl(name),
  {      
    ...options,
    method: 'PATCH'
    
    
  }
);}



/**
 * Retrieves the given process and its status
 * @summary Get process state
 */
export type getProcessResponse200 = {
  data: TypesProcessState
  status: 200
}

export type getProcessResponse400 = {
  data: GetProcess400
  status: 400
}

export type getProcessResponseSuccess = (getProcessResponse200) & {
  headers: Headers;
};
export type getProcessResponseError = (getProcessResponse400) & {
  headers: Headers;
};

export type getProcessResponse = (getProcessResponseSuccess | getProcessResponseError)

export const getGetProcessUrl = (name: string,) => {


  

  return `/process/${name}`
}

export const getProcess = async (name: string, options?: RequestInit): Promise<getProcessResponse> => {
  
  return pcFetch<getProcessResponse>(getGetProcessUrl(name),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



/**
 * Retrieves all the configured processes and their status
 * @summary Get all processes
 */
export type getProcessesResponse200 = {
  data: TypesProcessesState
  status: 200
}

export type getProcessesResponse400 = {
  data: GetProcesses400
  status: 400
}

export type getProcessesResponseSuccess = (getProcessesResponse200) & {
  headers: Headers;
};
export type getProcessesResponseError = (getProcessesResponse400) & {
  headers: Headers;
};

export type getProcessesResponse = (getProcessesResponseSuccess | getProcessesResponseError)

export const getGetProcessesUrl = () => {


  

  return `/processes`
}

export const getProcesses = async ( options?: RequestInit): Promise<getProcessesResponse> => {
  
  return pcFetch<getProcessesResponse>(getGetProcessesUrl(),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



/**
 * Sends kill signal to the processes list
 * @summary Stop processes
 */
export type stopProcessesResponse200 = {
  data: StopProcesses200
  status: 200
}

export type stopProcessesResponse207 = {
  data: StopProcesses207
  status: 207
}

export type stopProcessesResponse400 = {
  data: StopProcesses400
  status: 400
}

export type stopProcessesResponseSuccess = (stopProcessesResponse200 | stopProcessesResponse207) & {
  headers: Headers;
};
export type stopProcessesResponseError = (stopProcessesResponse400) & {
  headers: Headers;
};

export type stopProcessesResponse = (stopProcessesResponseSuccess | stopProcessesResponseError)

export const getStopProcessesUrl = () => {


  

  return `/processes/stop`
}

export const stopProcesses = async (stopProcessesBody: string[], options?: RequestInit): Promise<stopProcessesResponse> => {
  
  return pcFetch<stopProcessesResponse>(getStopProcessesUrl(),
  {      
    ...options,
    method: 'PATCH',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      stopProcessesBody,)
  }
);}



/**
 * Update running project
 * @summary Updates running processes
 */
export type updateProjectResponse200 = {
  data: UpdateProject200
  status: 200
}

export type updateProjectResponse207 = {
  data: UpdateProject207
  status: 207
}

export type updateProjectResponse400 = {
  data: UpdateProject400
  status: 400
}

export type updateProjectResponseSuccess = (updateProjectResponse200 | updateProjectResponse207) & {
  headers: Headers;
};
export type updateProjectResponseError = (updateProjectResponse400) & {
  headers: Headers;
};

export type updateProjectResponse = (updateProjectResponseSuccess | updateProjectResponseError)

export const getUpdateProjectUrl = () => {


  

  return `/project`
}

export const updateProject = async ( options?: RequestInit): Promise<updateProjectResponse> => {
  
  return pcFetch<updateProjectResponse>(getUpdateProjectUrl(),
  {      
    ...options,
    method: 'POST'
    
    
  }
);}



/**
 * Reload project state from config
 * @summary Reload project
 */
export type reloadProjectResponse200 = {
  data: ReloadProject200
  status: 200
}

export type reloadProjectResponse207 = {
  data: ReloadProject207
  status: 207
}

export type reloadProjectResponse400 = {
  data: ReloadProject400
  status: 400
}

export type reloadProjectResponseSuccess = (reloadProjectResponse200 | reloadProjectResponse207) & {
  headers: Headers;
};
export type reloadProjectResponseError = (reloadProjectResponse400) & {
  headers: Headers;
};

export type reloadProjectResponse = (reloadProjectResponseSuccess | reloadProjectResponseError)

export const getReloadProjectUrl = () => {


  

  return `/project/configuration`
}

export const reloadProject = async ( options?: RequestInit): Promise<reloadProjectResponse> => {
  
  return pcFetch<reloadProjectResponse>(getReloadProjectUrl(),
  {      
    ...options,
    method: 'POST'
    
    
  }
);}



/**
 * Get process compose project name
 * @summary Get Project Name
 */
export type getProjectNameResponse200 = {
  data: ApiProjectNameResponse
  status: 200
}

export type getProjectNameResponse400 = {
  data: GetProjectName400
  status: 400
}

export type getProjectNameResponseSuccess = (getProjectNameResponse200) & {
  headers: Headers;
};
export type getProjectNameResponseError = (getProjectNameResponse400) & {
  headers: Headers;
};

export type getProjectNameResponse = (getProjectNameResponseSuccess | getProjectNameResponseError)

export const getGetProjectNameUrl = () => {


  

  return `/project/name`
}

export const getProjectName = async ( options?: RequestInit): Promise<getProjectNameResponse> => {
  
  return pcFetch<getProjectNameResponse>(getGetProjectNameUrl(),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



/**
 * Retrieves project state information
 * @summary Get project state
 */
export type getProjectStateResponse200 = {
  data: TypesProjectState
  status: 200
}

export type getProjectStateResponse500 = {
  data: GetProjectState500
  status: 500
}

export type getProjectStateResponseSuccess = (getProjectStateResponse200) & {
  headers: Headers;
};
export type getProjectStateResponseError = (getProjectStateResponse500) & {
  headers: Headers;
};

export type getProjectStateResponse = (getProjectStateResponseSuccess | getProjectStateResponseError)

export const getGetProjectStateUrl = () => {


  

  return `/project/state`
}

export const getProjectState = async ( options?: RequestInit): Promise<getProjectStateResponse> => {
  
  return pcFetch<getProjectStateResponse>(getGetProjectStateUrl(),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



/**
 * Shuts down the server
 * @summary Stops all the processes and the server
 */
export type shutDownProjectResponse200 = {
  data: ApiStatusResponse
  status: 200
}

export type shutDownProjectResponseSuccess = (shutDownProjectResponse200) & {
  headers: Headers;
};
;

export type shutDownProjectResponse = (shutDownProjectResponseSuccess)

export const getShutDownProjectUrl = () => {


  

  return `/project/stop`
}

export const shutDownProject = async ( options?: RequestInit): Promise<shutDownProjectResponse> => {
  
  return pcFetch<shutDownProjectResponse>(getShutDownProjectUrl(),
  {      
    ...options,
    method: 'POST'
    
    
  }
);}
